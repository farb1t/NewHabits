<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>–¢—Ä–µ–∫–µ—Ä –ø—Ä–∏–≤—ã—á–µ–∫ ‚Äî —Ç—ë–º–Ω–∞—è —Ç–µ–º–∞</title>
<style>
    :root{
      --bg:#0b0c0f;
      --panel:#0f1114;
      --muted:#9aa0a6;
      --accent:#ff6b3d; /* –æ—Ä–∞–Ω–∂–µ–≤–æ-–∫—Ä–∞—Å–Ω—ã–π */
      --accent-2:#ff3b30;
      --glass: rgba(255,255,255,0.03);
      --success:#59e391;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, 'Helvetica Neue', Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; background:linear-gradient(180deg,var(--bg),#071014); color:#e6eef3; display:flex; align-items:stretch; justify-content:center;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .app{
      width:100%; max-width:420px; height:720px; margin:24px; border-radius:20px; overflow:hidden; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow:0 8px 30px rgba(0,0,0,0.7);
      display:flex; flex-direction:column;
    }
    header{
      padding:18px 18px 12px; display:flex; align-items:center; justify-content:space-between; gap:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06));
    }
    header h1{font-size:16px; margin:0}
    .top-actions{display:flex; gap:8px; align-items:center}
    button.icon-btn{background:var(--glass); border:1px solid rgba(255,255,255,0.03); color:var(--muted); padding:8px 10px; border-radius:10px; display:inline-flex; gap:8px; align-items:center; cursor:pointer}
    main{flex:1; overflow:auto; padding-bottom: 96px; flex:1; padding:16px; overflow:auto}

    /* Habit (task) cards */
    .habit-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)); padding:14px; border-radius:14px; border:1px solid rgba(255,255,255,0.03); margin-bottom:12px}
    .habit-title{display:flex; align-items:center; gap:12px}
    .color-dot{width:12px; height:12px; border-radius:4px}
    .progress{margin-top:12px}
    .bar{height:12px; background:rgba(255,255,255,0.04); border-radius:8px; overflow:hidden}
    .bar > i{display:block; height:100%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); width:0%}
    .sub{font-size:12px; color:var(--muted); margin-top:6px}

    /* Calendar */
    .calendar{margin-top:14px;}
    .cal-grid{display:grid; grid-template-columns:repeat(7,1fr); gap:6px}
    .cal-cell{background:rgba(255,255,255,0.02); border-radius:8px; min-height:56px; padding:6px; display:flex; flex-direction:column; justify-content:space-between}
    .cal-cell .day{font-weight:600}
    .cal-cell.done{background:linear-gradient(180deg, rgba(89,227,145,0.08), rgba(0,0,0,0.04)); border:1px solid rgba(89,227,145,0.12)}
    .cal-head{display:flex; justify-content:space-between; align-items:center}

    /* Today's task */
    .today-task{margin-top:14px; display:flex; gap:10px; align-items:center}
    .check{width:48px; height:48px; border-radius:12px; display:grid; place-items:center; cursor:pointer; border:1px solid rgba(255,255,255,0.03); background:var(--panel)}
    .task-info{flex:1}
    .complete{background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#fff}

    /* Chat */
    .chat{display:flex; flex-direction:column; height:100%}
    .messages{flex:1; overflow:auto; padding:8px; display:flex; flex-direction:column; gap:10px}
    .bubble{max-width:78%; padding:10px 12px; border-radius:12px}
    .bubble.bot{align-self:flex-start; background:rgba(255,255,255,0.03)}
    .bubble.you{align-self:flex-end; background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#000}
    .chat-input{display:flex; gap:8px; padding:12px}
    input[type=text]{flex:1; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit}

    /* Profile */
    .profile{display:flex; flex-direction:column; align-items:center; gap:12px}
    .avatar{width:120px; height:120px; border-radius:50%; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06)); display:grid; place-items:center; overflow:hidden; border:2px solid rgba(255,255,255,0.03)}
    .avatar img{width:100%; height:100%; object-fit:cover}
    .name{font-weight:700; font-size:18px}
    .streak{font-size:14px; color:var(--muted)}
    .medals{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; justify-content:center}
    .medal{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)); border-radius:12px; padding:10px; width:120px; text-align:center; border:1px solid rgba(255,255,255,0.03)}
    .medal small{display:block; color:var(--muted); font-size:12px; margin-top:8px}

    /* Bottom nav */
    nav.bottom{position:sticky; bottom:0; z-index:100; pointer-events:auto; height:78px; display:flex; align-items:center; justify-content:space-around; gap:10px; padding:12px; border-top:1px solid rgba(255,255,255,0.02); background:linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06))}
    .nav-btn{cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:6px; color:var(--muted); cursor:pointer; position:relative}
    .nav-btn.active{color:var(--accent)}
    .nav-badge{position:absolute; right:10px; top:4px; font-size:12px;}

    /* small helpers */
    .muted{color:var(--muted)}
    .hidden{display:none}
    .flex{display:flex}

    /* Highlight only the container behind the today checkmark */
    .today-check{
      transition: background 0.15s ease, box-shadow 0.15s ease;
      border-radius: 10px;
      padding: 6px 10px;
    }
    .today-check.done{
      background: #06d6a0;
      box-shadow: 0 2px 8px rgba(6,214,160,0.25);
    }

/* --- Hide scrollbar UI across browsers, keep scroll ability --- */
* { scrollbar-width: none; }            /* Firefox */
*::-webkit-scrollbar { width: 0; height: 0; display: none; } /* WebKit */
html, body { -ms-overflow-style: none; } /* IE/Edge legacy */

</style>
</head>
<body data-avatar-ready="1">
<div class="app" role="application">
  <header>
    <h1 id="header-title">–ü—Ä–∏–≤—ã—á–∫–∏</h1>
  </header>
  <main>
    <!-- TASKS (ALL HABITS) VIEW -->
    <section class="view" id="view-habit">
      <div id="habit-list"></div>
      <div class="habit-card" id="trash-panel" style="display:none;">
        <div style="font-weight:700; margin-bottom:8px">–ö–æ—Ä–∑–∏–Ω–∞</div>
        <div class="sub" id="trash-list">–ü—É—Å—Ç–æ</div>
      </div>
    </section>

    <!-- CHAT VIEW -->
    <section class="view hidden" id="view-chat">
      <div class="chat" style="height:100%">
        <div class="messages" id="messages"></div>
        <div class="chat-input">
          <input autocomplete="off" id="chat-input" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." type="text"/>
          <button class="icon-btn" id="send-btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
        </div>
      </div>
      <div class="habit-card" id="trash-panel-chat" style="margin-top:12px; display:none;">
        <div style="font-weight:700; margin-bottom:8px">–ö–æ—Ä–∑–∏–Ω–∞</div>
        <div class="sub" id="trash-list-chat">–ü—É—Å—Ç–æ</div>
      </div>
    </section>

    <!-- PROFILE VIEW -->
    <section class="view hidden" id="view-profile">
      <div class="profile">
        <label class="avatar" id="avatar-label">
          <img alt="avatar" class="hidden" id="avatar-img" src=""/>
          <div id="avatar-placeholder">üë§</div>
          <input accept="image/*" id="avatar-input" style="display:none" type="file"/>
        </label>
        <div>
          <div class="name" id="profile-name">–ì–æ—Å—Ç—å</div>
          <div class="streak" id="profile-streak">Streak: 0</div>
        </div>
        <h3 style="margin-top:16px">–ù–∞–≥—Ä–∞–¥—ã</h3>
        <div class="medals" id="medals">
          <!-- medals injected -->
        </div>
      </div>
    </section>
  </main>

  <nav class="bottom">
    <div class="nav-btn active" data-view="view-habit" id="nav-1">
      <svg fill="none" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M12 2v20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"></path><path d="M5 12h14" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"></path></svg>
      <div style="font-size:12px">–ó–∞–¥–∞–Ω–∏—è</div>
      <span class="nav-badge">‚úì</span>
    </div>
    <div class="nav-btn" data-view="view-chat" id="nav-2">
      <svg fill="none" height="22" viewBox="0 0 24 24" width="22"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.4"></path></svg>
      <div style="font-size:12px">–ß–∞—Ç</div>
    </div>
    <div class="nav-btn" data-view="view-profile" id="nav-3">
      <svg fill="none" height="22" viewBox="0 0 24 24" width="22"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.4"></path><circle cx="12" cy="7" r="4" stroke="currentColor" stroke-width="1.4"></circle></svg>
      <div style="font-size:12px">–ü—Ä–æ—Ñ–∏–ª—å</div>
    </div>
  </nav>
</div>

<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  function isoDate(d){ const t=new Date(d.getFullYear(), d.getMonth(), d.getDate()); return t.toISOString().slice(0,10); }
  function daysBetween(a,b){ const ms = (new Date(b) - new Date(a)); return Math.max(0, Math.round(ms/86400000)+1); }

  const defaultState = {
    profile: {name:'–ì–æ—Å—Ç—å', avatar: '', streak:0},
    habits: [],
    trash: [],
    currentHabitId: null
  };

  function saveState(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }
  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return JSON.parse(JSON.stringify(defaultState));
      const s = JSON.parse(raw);
      if(!('trash' in s)) s.trash = [];
      return s;
    }catch(e){ return JSON.parse(JSON.stringify(defaultState)); }
  }

  // DOM
  const views = Array.from(document.querySelectorAll('.view'));
  const navBtns = Array.from(document.querySelectorAll('.nav-btn'));
  const headerTitle = document.getElementById('header-title');
  const listRoot = document.getElementById('habit-list');
  const trashPanel = document.getElementById('trash-panel');
  const trashList = document.getElementById('trash-list');

  const sendBtn = document.getElementById('send-btn');
  const chatInput = document.getElementById('chat-input');
  const messages = document.getElementById('messages');

  const profileNameEl = document.getElementById('profile-name');
  const profileStreakEl = document.getElementById('profile-streak');
  const avatarImg = document.getElementById('avatar-img');
  const avatarPlaceholder = document.getElementById('avatar-placeholder');
  const avatarInput = document.getElementById('avatar-input');
  const avatarLabel = document.getElementById('avatar-label');


  let state = loadState();
  if(!('pending' in state)) state.pending = null;

  const COLOR_PALETTE = ['#ff6b3d', '#ff3b30', '#59e391', '#4da3ff', '#c792ea', '#ffd166', '#06d6a0', '#f469a9'];
  function uid(){ return 'h' + Math.random().toString(36).slice(2,9); }
  function pickColor(){
    const used = state.habits.map(h=>h.color).filter(Boolean);
    for(const c of COLOR_PALETTE){ if(!used.includes(c)) return c; }
    return COLOR_PALETTE[Math.floor(Math.random()*COLOR_PALETTE.length)];
  }
  function createHabit(name){
    if(state.pending && state.pending.type==='duration') state.pending = null;
    const n = (name||'–ù–æ–≤–∞—è –ø—Ä–∏–≤—ã—á–∫–∞').trim();
    const id = uid();
    const h = { id, name: n, color: pickColor(), start: isoDate(new Date()), days: [] };
    state.habits.unshift(h);
    state.currentHabitId = id;
    saveState(state);
    renderAll();
    return h;
  }

  function showView(id){
    views.forEach(v=> v.id===id? v.classList.remove('hidden') : v.classList.add('hidden'));
    navBtns.forEach(b=> b.dataset.view===id ? b.classList.add('active') : b.classList.remove('active'));
    if(id==='view-habit') headerTitle.textContent = '–ü—Ä–∏–≤—ã—á–∫–∏';
    else if(id==='view-chat') headerTitle.textContent = '–ß–∞—Ç';
    else if(id==='view-profile') headerTitle.textContent = '–ü—Ä–æ—Ñ–∏–ª—å';
  }

  // Calendar renderer for a given container & habit
  function renderCalendar(h, wrapper, ym){
    wrapper.innerHTML = '';
    const head = document.createElement('div'); head.className='cal-head';
    const monthLabel = document.createElement('div'); monthLabel.className='muted';
    const ctrls = document.createElement('div'); ctrls.style.display='flex'; ctrls.style.gap='8px';
    const prev = document.createElement('button'); prev.className='icon-btn'; prev.textContent='‚óÄ';
    const next = document.createElement('button'); next.className='icon-btn'; next.textContent='‚ñ∂';
    ctrls.appendChild(prev); ctrls.appendChild(next);
    head.appendChild(monthLabel); head.appendChild(ctrls);
    const grid = document.createElement('div'); grid.className='cal-grid';

    wrapper.appendChild(head); wrapper.appendChild(grid);

    const base = ym || { y:new Date().getFullYear(), m:new Date().getMonth() };
    let Y = base.y, M = base.m;

    function draw(y, m){
      grid.innerHTML='';
      const first = new Date(y,m,1);
      const last = new Date(y,m+1,0);
      monthLabel.textContent = first.toLocaleString('ru-RU', {month:'long', year:'numeric'});
      const wk=['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–í—Å'];
      wk.forEach(w=>{ const el=document.createElement('div'); el.className='cal-cell'; el.style.background='transparent'; el.style.minHeight='18px'; el.style.padding='6px 0'; el.style.display='flex'; el.style.alignItems='center'; el.style.justifyContent='center'; el.style.fontSize='12px'; el.textContent=w; grid.appendChild(el); });
      let startDay = first.getDay(); startDay = startDay===0?7:startDay;
      for(let i=1;i<startDay;i++){ const el=document.createElement('div'); el.className='cal-cell'; el.style.opacity=.1; grid.appendChild(el); }
      const todayKey = isoDate(new Date());
      for(let d=1; d<=last.getDate(); d++){
        const dateStr = isoDate(new Date(y,m,d));
        const cell=document.createElement('div'); cell.className='cal-cell';
        const top=document.createElement('div'); top.className='day'; top.textContent=d; cell.appendChild(top);
        const dot=document.createElement('div'); dot.style.height='8px'; dot.style.width='8px'; dot.style.borderRadius='6px'; dot.style.marginTop='6px';
        if(h.days.includes(dateStr)){ cell.classList.add('done'); dot.style.background='var(--success)'; } else { dot.style.background='transparent'; }
        cell.appendChild(dot);
        if(dateStr === todayKey){
          cell.style.cursor='pointer'; cell.title='–û—Ç–º–µ—Ç–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞ —Å–µ–≥–æ–¥–Ω—è';
          cell.addEventListener('click', ()=>{
            if(h.days.includes(todayKey)){ h.days = h.days.filter(x=>x!==todayKey); } else { h.days.push(todayKey); }
            saveState(state);
            draw(y,m);
            renderAll();
          });
        } else {
          cell.style.pointerEvents='none'; cell.title='–ú–æ–∂–Ω–æ –æ—Ç–º–µ—á–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å'; cell.style.opacity = 0.85;
        }
        grid.appendChild(cell);
      }
    }
    draw(Y,M);
    prev.addEventListener('click', ()=>{ M--; if(M<0){M=11; Y--;} draw(Y,M); });
    next.addEventListener('click', ()=>{ M++; if(M>11){M=0; Y++;} draw(Y,M); });
  }


  // Compute streak as consecutive days with at least one habit completed (today, yesterday, ...)
  function computeStreak(){
    let streak = 0;
    if(!state.habits || state.habits.length === 0) return 0;
    const d = new Date();
    // Walk backwards day by day
    while(true){
      const key = isoDate(d);
      const anyDone = state.habits.some(h => Array.isArray(h.days) && h.days.includes(key));
      if(anyDone){ streak++; d.setDate(d.getDate()-1); } else { break; }
    }
    return streak;
  }

  function renderProfile(){
    try{
      // Name
      profileNameEl.textContent = state?.profile?.name || '–ì–æ—Å—Ç—å';
      // Avatar
      const src = state?.profile?.avatar || '';
      if(src){
        avatarImg.src = src;
        avatarImg.classList.remove('hidden');
        avatarPlaceholder.style.display = 'none';
      } else {
        avatarImg.src = '';
        avatarImg.classList.add('hidden');
        avatarPlaceholder.style.display = 'grid';
      }
      // Streak
      const s = computeStreak();
      state.profile.streak = s;
      saveState(state);
      profileStreakEl.textContent = 'Streak: ' + s;
    }catch(e){ /* noop */ }
  }

  function computeProgress(h){
    const elapsed = Math.max(1, daysBetween(h.start, isoDate(new Date())));
    const total = h.targetDays ? Math.max(1, h.targetDays) : elapsed;
    const done = Math.min(h.days.length, total);
    const pct = Math.min(100, Math.round(done/total*100));
    return {elapsed, total, done, pct};
  }

  function setNavBadge(doneToday){
    const navBadge = document.querySelector('#nav-1 .nav-badge'); if(!navBadge) return;
    try{
      const today=isoDate(new Date());
      const lit = sessionStorage.getItem('badgeLitDate') === today;
      navBadge.style.display = (doneToday && lit) ? 'block' : 'none';
    } catch(e){
      navBadge.style.display = doneToday ? 'block' : 'none';
    }
  }

  function renderTrash(){
    if(!trashPanel || !trashList) return;
    if(!state.trash || state.trash.length===0){
      trashPanel.style.display='none';
      trashList.textContent='–ü—É—Å—Ç–æ';
      return;
    }
    trashPanel.style.display='block';
    trashList.innerHTML='';
    state.trash.forEach(h=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px 0';
      const left = document.createElement('div'); left.textContent = h.name; left.className='sub';
      const btn = document.createElement('button'); btn.className='icon-btn'; btn.textContent='–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
      btn.addEventListener('click', ()=> restoreHabit(h.id));
      row.appendChild(left); row.appendChild(btn);
      trashList.appendChild(row);
    });
  }

  function deleteHabit(id){
    const idx = state.habits.findIndex(h=>h.id===id);
    if(idx<0) return;
    const [removed] = state.habits.splice(idx,1);
    state.trash.unshift(removed);
    state.currentHabitId = state.habits.length ? state.habits[0].id : null;
    saveState(state);
    renderAll(); renderTrash();
  }
  function restoreHabit(id){
    const idx = state.trash.findIndex(h=>h.id===id);
    if(idx<0) return;
    const [restored] = state.trash.splice(idx,1);
    state.habits.unshift(restored);
    state.currentHabitId = restored.id;
    saveState(state);
    renderAll(); renderTrash();
  }

  // Render ALL habits
  function renderAll(){
    listRoot.innerHTML='';
    if(!state.habits.length){
      const empty = document.createElement('div');
      empty.className='sub';
      empty.textContent='–ù–µ—Ç –ø—Ä–∏–≤—ã—á–µ–∫. –î–æ–±–∞–≤—å—Ç–µ —á–µ—Ä–µ–∑ —á–∞—Ç –Ω–∏–∂–µ: –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, –∑–∞—Ç–µ–º —É–∫–∞–∂–∏—Ç–µ —Å—Ä–æ–∫ (–≤ –¥–Ω—è—Ö).';
      listRoot.appendChild(empty);
      setNavBadge(false);
      renderTrash();
      return;
    }

    let anyDoneToday = false;
    state.habits.forEach(h=>{
      const {total, done, pct} = computeProgress(h);
      const card = document.createElement('div'); card.className='habit-card';

      // Title row
      const title = document.createElement('div'); title.className='habit-title';
      const dot = document.createElement('div'); dot.className='color-dot'; dot.style.background = h.color || 'var(--accent)';
      const titleWrap = document.createElement('div'); titleWrap.style.flex='1';
      const nameEl = document.createElement('div'); nameEl.style.fontWeight='700'; nameEl.style.fontSize='16px'; nameEl.textContent = h.name;
      const durationEl = document.createElement('div'); durationEl.className='sub'; durationEl.textContent = `–°—Ä–æ–∫: ${total} –¥–Ω.`;
      titleWrap.appendChild(nameEl); titleWrap.appendChild(durationEl);

      const right = document.createElement('div'); right.style.textAlign='right';
      const subProg = document.createElement('div'); subProg.className='sub'; subProg.textContent='–ü—Ä–æ–≥—Ä–µ—Å—Å';
      const pctEl = document.createElement('div'); pctEl.className='sub'; pctEl.textContent = pct+'%';
      right.appendChild(subProg); right.appendChild(pctEl);

      const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.title='–£–¥–∞–ª–∏—Ç—å –ø—Ä–∏–≤—ã—á–∫—É'; delBtn.textContent='üóëÔ∏è';
      delBtn.style.marginLeft='8px';
      delBtn.addEventListener('click', ()=>{ if(confirm('–£–¥–∞–ª–∏—Ç—å –ø—Ä–∏–≤—ã—á–∫—É –≤ –∫–æ—Ä–∑–∏–Ω—É?')) deleteHabit(h.id); });

      title.appendChild(dot); title.appendChild(titleWrap); title.appendChild(right); title.appendChild(delBtn);
      card.appendChild(title);

      // Progress
      const progress = document.createElement('div'); progress.className='progress';
      const bar = document.createElement('div'); bar.className='bar';
      const fill = document.createElement('i'); fill.style.width = pct+'%';
      bar.appendChild(fill);
      const sub = document.createElement('div'); sub.className='sub'; sub.textContent = `${done} / ${total} –≤—ã–ø–æ–ª–Ω–µ–Ω–æ`;
      progress.appendChild(bar); progress.appendChild(sub);
      card.appendChild(progress);

      // Today row
      const todayRow = document.createElement('div'); todayRow.className='today-task';
      const todayKey = isoDate(new Date());
      const doneToday = h.days.includes(todayKey); if(doneToday) anyDoneToday = true;
      const check = document.createElement('div'); check.className='check today-check' + (doneToday ? ' done' : '');
      check.textContent = '‚úî';
      check.addEventListener('click', ()=>{
        if(h.days.includes(todayKey)){ h.days = h.days.filter(d=>d!==todayKey); } else { h.days.push(todayKey); }
        saveState(state); renderAll();
      });
      const ti = document.createElement('div'); ti.className='task-info';
      const tt = document.createElement('div'); tt.style.fontWeight='700'; tt.textContent = '–°–µ–≥–æ–¥–Ω—è';
      const ts = document.createElement('div'); ts.className='sub'; ts.textContent = doneToday ? '–°–µ–≥–æ–¥–Ω—è ‚Äî ‚úî' : '–°–µ–≥–æ–¥–Ω—è ‚Äî ‚úñ';
      ti.appendChild(tt); ti.appendChild(ts);
      const muted = document.createElement('div'); muted.className='muted'; muted.textContent = doneToday ? '–í—ã–ø–æ–ª–Ω–µ–Ω–æ' : '–ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ';
      todayRow.appendChild(check); todayRow.appendChild(ti); todayRow.appendChild(muted);
      card.appendChild(todayRow);

      // Toggle calendar button
      const toggleWrap = document.createElement('div'); toggleWrap.style.marginTop='10px'; toggleWrap.style.display='flex'; toggleWrap.style.gap='8px';
      const toggleBtn = document.createElement('button'); toggleBtn.className='icon-btn'; toggleBtn.textContent='–ö–∞–ª–µ–Ω–¥–∞—Ä—å';
      toggleWrap.appendChild(toggleBtn);
      card.appendChild(toggleWrap);

      // Calendar (hidden by default)
      const cal = document.createElement('div'); cal.className='calendar hidden';
      card.appendChild(cal);

      let calRendered = false;
      toggleBtn.addEventListener('click', ()=>{
        cal.classList.toggle('hidden');
        if(!calRendered){ renderCalendar(h, cal); calRendered = true; }
      });

      listRoot.appendChild(card);
    });

    setNavBadge(anyDoneToday);
    renderTrash();
    renderProfile();
  }

  // Chat (same simple flow as before)
  function pushMsg(text, from='you'){
    const b = document.createElement('div');
    b.className = from==='you' ? 'bubble you' : 'bubble bot';
    b.textContent = text;
    messages.appendChild(b);
    messages.scrollTop = messages.scrollHeight;
  }
  
  function parseHabitIntent(text){
    const t = text.trim();
    // Normalize spaces
    let clean = t.replace(/\s+/g,' ').trim();

    // Extract number of days (1..365)
    const numMatch = clean.match(/(\d{1,3})/);
    const days = numMatch ? Math.max(1, Math.min(365, parseInt(numMatch[1],10))) : null;

    // Remove helper words and the number to isolate a probable name
    let name = clean
      .replace(/^(–¥–æ–±–∞–≤(—å|–∏)|–¥–æ–±–∞–≤–∏—Ç—å|—Å–æ–∑–¥–∞–π|—Å–æ–∑–¥–∞—Ç—å|–ø—Ä–∏–±–∞–≤—å|—Å–¥–µ–ª–∞–π)\s*/i,'')
      .replace(/\b–Ω–∞\s+\d{1,3}\s*(–¥–Ω(—è|–µ–π)?|–¥–Ω—è|–¥–Ω–µ–π)?\b/gi,'')
      .replace(/\b\d{1,3}\s*(–¥–Ω(—è|–µ–π)?|–¥–Ω—è|–¥–Ω–µ–π)?\b/gi,'')
      .replace(/\b–¥–Ω(—è|–µ–π)?\b/gi,'')
      .replace(/\b–¥–µ–Ω—å\b/gi,'')
      .replace(/\s+/g,' ').trim();

    // If message looks like a habit name (2..40 chars) and not only filler words
    const looksLikeName = /^[\w–ê-–Ø–∞-—è–Å—ë\s.,!()\-\u2013\u2014]{2,40}$/.test(name || '') && !/–¥–Ω|–¥–Ω–µ–π|day|days/i.test(name || '');

    if(looksLikeName){
      return { name, days };
    }
    // If the whole text looks like a name (without cleaning)
    const asName = /^[\w–ê-–Ø–∞-—è–Å—ë\s.,!()\-\u2013\u2014]{2,40}$/.test(clean) && !/–¥–Ω|–¥–Ω–µ–π|day|days/i.test(clean);
    if(asName){
      return { name: clean, days };
    }
    return null;
  }

  function botReply(q){
    const text = q.trim();

    // If we're waiting for duration, prioritize that flow
    if(state.pending && state.pending.type==='duration' && state.pending.habitId){
      const num = (text.match(/(\d{1,3})/)||[])[1];
      if(num){
        const n = Math.max(1, Math.min(365, parseInt(num,10)));
        const h = state.habits.find(x=>x.id===state.pending.habitId);
        if(h){ h.targetDays = n; saveState(state); renderAll(); }
        pushMsg(`–û—Ç–ª–∏—á–Ω–æ, —Å—Ç–∞–≤–ª—é —Å—Ä–æ–∫: ${n} –¥–Ω–µ–π.`, 'bot');
        state.pending = null; saveState(state);
        showView('view-habit');
        return;
      } else {
        pushMsg('–ù–∞–ø–∏—à–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π, –Ω–∞–ø—Ä–∏–º–µ—Ä: 30', 'bot');
        return;
      }
    }

    // New: try to parse full intent from a single message
    const parsed = parseHabitIntent(text);
    if(parsed && parsed.name){
      const h = createHabit(parsed.name);
      if(parsed.days){
        h.targetDays = parsed.days;
        saveState(state); renderAll();
        pushMsg(`–î–æ–±–∞–≤–∏–ª: ¬´${h.name}¬ª –Ω–∞ ${parsed.days} –¥–Ω–µ–π. –£–¥–∞—á–∏!`, 'bot');
        showView('view-habit');
        return;
      } else {
        pushMsg(`–î–æ–±–∞–≤–∏–ª: ¬´${h.name}¬ª. –ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–ª–∞–Ω–∏—Ä—É–µ—à—å? –ù–∞–ø–∏—à–∏ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä: 30`, 'bot');
        state.pending = { type:'duration', habitId: h.id }; saveState(state);
        return;
      }
    }

    // Legacy flows below kept for compatibility
    if(state.pending && state.pending.type==='name'){
      const name = text.replace(/^–ø—Ä–∏–≤—ã—á(–∫–∞|–∫—É)?\s*/i, '').trim() || '–ù–æ–≤–∞—è –ø—Ä–∏–≤—ã—á–∫–∞';
      const h = createHabit(name);
      pushMsg(`–î–æ–±–∞–≤–∏–ª: ¬´${h.name}¬ª. –ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–ª–∞–Ω–∏—Ä—É–µ—à—å? –ù–∞–ø–∏—à–∏ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä: 30`, 'bot');
      state.pending = { type:'duration', habitId: h.id }; saveState(state);
      return;
    }

    const numInline = (text.match(/(\d{1,3})/)||[])[1];
    if(numInline){
      const h = state.habits[0];
      if(h){
        const n = Math.max(1, Math.min(365, parseInt(numInline,10)));
        h.targetDays = n; saveState(state); renderAll();
        pushMsg(`–û–∫, —Å—Ä–æ–∫ –¥–ª—è ¬´${h.name}¬ª: ${n} –¥–Ω–µ–π.`, 'bot');
        return;
      }
    }

    const looksLikeName = /^[\w–ê-–Ø–∞-—è–Å—ë\s.,!()\-\u2013\u2014]{2,40}$/.test(text) && !/–¥–Ω|–¥–Ω–µ–π|day|days/i.test(text);
    if(looksLikeName){
      const h = createHabit(text);
      pushMsg(`–î–æ–±–∞–≤–∏–ª: ¬´${h.name}¬ª. –ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–ª–∞–Ω–∏—Ä—É–µ—à—å? –ù–∞–ø–∏—à–∏ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä: 30`, 'bot');
      state.pending = { type:'duration', habitId: h.id }; saveState(state);
      return;
    }

    if(!state.habits || state.habits.length===0){
      pushMsg('–ß—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ –ø—Ä–∏–≤—ã—á–∫–∏? –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´–ü–∏—Ç—å –≤–æ–¥—É¬ª.', 'bot');
      state.pending = { type:'name' }; saveState(state);
    } else {
      pushMsg('–ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏, –∫–æ—Ç–æ—Ä—É—é –¥–æ–±–∞–≤–∏—Ç—å. –ú–æ–∂–Ω–æ —Å—Ä–∞–∑—É —É–∫–∞–∑–∞—Ç—å —Å—Ä–æ–∫: ¬´–ü–∏—Ç—å –≤–æ–¥—É 30¬ª.', 'bot');
      state.pending = { type:'name' }; saveState(state);
    }
  }

  function send(){
    const t = (chatInput?.value||'').trim();
    if(!t) return;
    pushMsg(t, 'you'); chatInput.value=''; botReply(t);
  }
  sendBtn?.addEventListener('click', send);
  chatInput?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') send(); });


  // Avatar upload handler
  if(avatarLabel && avatarInput){
    avatarLabel.addEventListener('click', ()=> avatarInput.click());
    avatarInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        try{
          state.profile.avatar = dataUrl;
          saveState(state);
        }catch(err){}
        renderProfile();
      };
      reader.readAsDataURL(file);
    });
  }

  // Nav
  document.addEventListener('click', (ev)=>{
    const navBtn = ev.target.closest('.nav-btn');
    if(navBtn && navBtn.dataset && navBtn.dataset.view) showView(navBtn.dataset.view);
  });

  // Init
  renderAll();
  showView('view-habit');

  renderProfile();
  try{
    const askedKey = 'profile_name_asked_v1';
    const askedBefore = localStorage.getItem(askedKey) === '1';
    if(!askedBefore){
      const nm = prompt('–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?');
      if(nm && nm.trim()){
        state.profile.name = nm.trim();
        saveState(state);
      }
      localStorage.setItem(askedKey, '1');
      renderProfile();
    }
  }catch(e){}

  try{
    const welcomedKey = 'habit_welcome_shown';
    const was = sessionStorage.getItem(welcomedKey);
    if(!was){
      pushMsg('–ü—Ä–∏–≤–µ—Ç! –ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏ ‚Äî —è –¥–æ–±–∞–≤–ª—é –µ—ë –∏ —Å–ø—Ä–æ—à—É —Å—Ä–æ–∫ (–≤ –¥–Ω—è—Ö).', 'bot');
      sessionStorage.setItem(welcomedKey, '1');
    }
  }catch(e){}

  // Debug badge
  try{
    const badge = document.createElement('div');
    badge.textContent = 'JS OK';
    badge.style.position='fixed'; badge.style.right='10px'; badge.style.bottom='10px';
    badge.style.background='rgba(0,0,0,0.5)'; badge.style.padding='6px 10px'; badge.style.borderRadius='8px'; badge.style.fontSize='12px';
    badge.style.zIndex='9999';
    document.body.appendChild(badge);
    setTimeout(()=>badge.remove(), 1500);
  }catch(e){}
})();

// --- Mobile-friendly avatar upload ---
(function(){
  // Try to detect an avatar <img> or clickable area
  const avatarImg = document.querySelector('.profile-avatar img, img#avatar, .avatar img, .user-avatar img') ||
                    document.querySelector('#avatar, .profile-avatar, .avatar, .user-avatar');

  const fileInput = document.getElementById('avatarFile');

  function loadSavedAvatar(){
    try {
      const saved = localStorage.getItem('profile.avatar');
      if(saved && avatarImg){
        if(avatarImg.tagName.toLowerCase()==='img'){
          avatarImg.src = saved;
        } else {
          avatarImg.style.backgroundImage = 'url(' + saved + ')';
          avatarImg.style.backgroundSize = 'cover';
          avatarImg.style.backgroundPosition = 'center';
        }
      }
    } catch(e){ /* noop */ }
  }

  function dataURLFromFile(file, done){
    const reader = new FileReader();
    reader.onload = () => done(null, reader.result);
    reader.onerror = err => done(err);
    reader.readAsDataURL(file);
  }

  function resizeDataURL(dataURL, maxSize, cb){
    const img = new Image();
    img.onload = function(){
      let w = img.width, h = img.height;
      if(w <= maxSize && h <= maxSize){
        return cb(null, dataURL);
      }
      if(w > h){
        h = Math.round(h * (maxSize / w));
        w = maxSize;
      } else {
        w = Math.round(w * (maxSize / h));
        h = maxSize;
      }
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      // Use JPEG to reduce size, fallback to PNG
      let out = canvas.toDataURL('image/jpeg', 0.85);
      if(!out) out = canvas.toDataURL('image/png');
      cb(null, out);
    };
    img.onerror = function(){ cb(new Error('image load failed')); };
    img.src = dataURL;
  }

  function setAvatar(src){
    try {
      localStorage.setItem('profile.avatar', src);
    } catch(e){ /* quota might fail, ignore */ }
    if(avatarImg){
      if(avatarImg.tagName.toLowerCase()==='img'){
        avatarImg.src = src;
      } else {
        avatarImg.style.backgroundImage = 'url(' + src + ')';
        avatarImg.style.backgroundSize = 'cover';
        avatarImg.style.backgroundPosition = 'center';
      }
    }
  }

  function handleFiles(files){
    const f = files && files[0];
    if(!f) return;
    if(!/^image\\//i.test(f.type)) return;
    dataURLFromFile(f, function(err, dataURL){
      if(err) return;
      resizeDataURL(dataURL, 512, function(err2, resized){
        if(err2 || !resized) return;
        setAvatar(resized);
      });
    });
  }

  function init(){
    if(!fileInput) return;
    // iOS requires user gesture: click on avatar should trigger file input
    if(avatarImg){
      const makeClickable = (el)=>{
        el.style.cursor = 'pointer';
        el.setAttribute('role','button');
        el.setAttribute('tabindex','0');
        const openPicker = ()=> fileInput && fileInput.click();
        el.addEventListener('click', openPicker, {passive:true});
        el.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); openPicker(); } });
      };
      makeClickable(avatarImg);
    }
    fileInput.addEventListener('change', function(e){
      handleFiles(e.target.files);
      // Reset value so selecting the same file again still fires change
      e.target.value = '';
    }, {passive:true});

    // Restore saved avatar on load
    loadSavedAvatar();
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

</script>
<style>.bottom *{pointer-events:auto !important;}</style>

  <input type="file" id="avatarFile" accept="image/*" capture="user" style="position:absolute;left:-9999px;opacity:0;width:1px;height:1px;" aria-hidden="true">

<!-- === Gamified Badges Injection: start === -->
<style>
  /* Badges: gamified look */
  .badges-wrap{width:100%;}
  .badge{
    width:104px; height:120px;
    background: radial-gradient(120px 120px at 50% 0%, rgba(255,255,255,0.10), rgba(0,0,0,0.12));
    border:1px solid rgba(255,255,255,0.06);
    border-radius:16px; padding:10px 10px 12px;
    display:flex; flex-direction:column; align-items:center; justify-content:space-between;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04);
    position:relative;
    transition: transform .18s ease, box-shadow .18s ease, filter .18s ease, opacity .18s ease;
  }
  .badge.locked{filter: grayscale(100%) brightness(0.8); opacity:0.55;}
  .badge.unlocked{animation: pop-in .5s ease both;}
  .badge .label{font-size:11px; color:var(--muted); margin-top:6px; text-transform:uppercase; letter-spacing:.03em}
  .badge .value{font-weight:800; font-size:18px; line-height:1.1}
  .badge .aura{
    position:absolute; inset:-2px; border-radius:18px; pointer-events:none;
    background: conic-gradient(from 0deg, rgba(255,107,61,0.0), rgba(255,59,48,0.25), rgba(255,255,255,0.0));
    filter: blur(14px); opacity:0; transition: opacity .18s ease;
  }
  .badge.unlocked .aura{opacity:1;}
  @keyframes pop-in{ 0%{transform:scale(.7); opacity:0} 60%{transform:scale(1.08); opacity:1} 100%{transform:scale(1)} }
  .badge svg{display:block}
  .medals{gap:12px !important}
  .streak-chip{
    display:inline-flex; align-items:center; gap:6px;
    padding:6px 10px; border-radius:999px; font-weight:700;
    background:linear-gradient(90deg, #ff9a5a, #ff3b30);
    color:#0b0c0f; box-shadow:0 6px 20px rgba(255,90,48,0.35);
  }
  .toast{
    position:fixed; left:50%; bottom:100px; transform:translateX(-50%);
    background:linear-gradient(180deg, rgba(40,40,40,.9), rgba(0,0,0,.9));
    color:#fff; padding:14px 16px; border-radius:14px; border:1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 24px rgba(0,0,0,0.45); z-index:99999; display:none; white-space:nowrap;
  }
  .toast.show{display:block; animation: pop-in .5s ease both;}
  .sparkles{position:fixed; inset:0; pointer-events:none; z-index:99998}
  .sparkles i{
    position:absolute; font-style:normal; opacity:0; animation: sparkle-fall 900ms ease-out forwards;
  }
  @keyframes sparkle-fall{
    0%{transform:translateY(0) rotate(0deg) scale(.8); opacity:0}
    15%{opacity:1}
    100%{transform:translateY(120px) rotate(120deg) scale(1); opacity:0}
  }
</style>
<script>
(function(){
  const BADGES = {
    streak:[7,14,21,30,45,60,75,90,100,120],
    mastered:[1,2,3,4,5]
  };

  // Create flame/trophy SVGs (gamified style)
  function badgeSVG(type, n){
    if(type==='streak'){
      return `
      <svg width="64" height="64" viewBox="0 0 64 64">
        <defs>
          <linearGradient id="g1" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0%" stop-color="#ffd166"/>
            <stop offset="60%" stop-color="#ff6b3d"/>
            <stop offset="100%" stop-color="#ff3b30"/>
          </linearGradient>
        </defs>
        <g filter="url(#none)">
          <path d="M32 6 C38 14, 46 20, 46 29 c0 10-8 18-14 21-6-3-14-11-14-21 0-9 8-15 14-23z" fill="url(#g1)"></path>
          <circle cx="32" cy="32" r="10" fill="rgba(0,0,0,0.15)"></circle>
          <text x="32" y="36" text-anchor="middle" font-size="14" font-weight="800" fill="#0b0c0f">${n}</text>
        </g>
      </svg>`;
    } else {
      return `
      <svg width="64" height="64" viewBox="0 0 64 64">
        <defs>
          <linearGradient id="g2" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0%" stop-color="#ffd166"/>
            <stop offset="60%" stop-color="#59e391"/>
            <stop offset="100%" stop-color="#4da3ff"/>
          </linearGradient>
        </defs>
        <g>
          <path d="M16 12h32l-3 16a17 17 0 0 1-26 0l-3-16z" fill="url(#g2)"></path>
          <rect x="26" y="40" width="12" height="6" rx="2" fill="#ffd166"></rect>
          <rect x="22" y="48" width="20" height="6" rx="3" fill="#ffd166"></rect>
          <text x="32" y="36" text-anchor="middle" font-size="14" font-weight="800" fill="#0b0c0f">${n}</text>
        </g>
      </svg>`;
    }
  }

  function ensureBadgeState(){
    try{
      const raw = localStorage.getItem('habit_traker_demo_v3');
      if(!raw) return null;
      const s = JSON.parse(raw);
      if(!s.profile) s.profile = {name:"–ì–æ—Å—Ç—å", avatar:"", streak:0};
      if(!s.profile.badges) s.profile.badges = { streak:[], mastered:[] };
      localStorage.setItem('habit_traker_demo_v3', JSON.stringify(s));
      return s;
    }catch(e){ return null; }
  }

  function computeMasteredCount(state){
    let c = 0;
    (state.habits||[]).forEach(h=>{
      if(h && h.targetDays && Array.isArray(h.days)){
        if(h.days.length >= Math.max(1, h.targetDays)) c++;
      }
    });
    return c;
  }

  // Simple sparkles & toast
  function showToast(msg){
    let el = document.getElementById('toast');
    if(!el){
      el = document.createElement('div');
      el.id = 'toast'; el.className = 'toast';
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.classList.add('show');
    setTimeout(()=>el.classList.remove('show'), 1600);
  }

  function sparkles(x, y){
    let wrap = document.getElementById('sparkles');
    if(!wrap){
      wrap = document.createElement('div'); wrap.id='sparkles'; wrap.className='sparkles';
      document.body.appendChild(wrap);
    }
    const glyphs = ['‚ú®','‚≠ê','üî•','üèÜ','üí•','üéâ'];
    for(let i=0;i<16;i++){
      const iEl = document.createElement('i');
      iEl.textContent = glyphs[Math.floor(Math.random()*glyphs.length)];
      iEl.style.left = (x + (Math.random()*120-60)) + 'px';
      iEl.style.top  = (y + (Math.random()*20-10)) + 'px';
      iEl.style.fontSize = (14 + Math.random()*10) + 'px';
      wrap.appendChild(iEl);
      setTimeout(()=> iEl.remove(), 950);
    }
  }

  // Render or update medals list
  function renderBadges(state){
    const box = document.getElementById('medals');
    if(!box) return;

    // Make sure badge arrays exist
    state.profile = state.profile || {};
    state.profile.badges = state.profile.badges || {streak:[], mastered:[]};

    const nowStreak = (state.profile && state.profile.streak) || 0;
    const masteredCount = computeMasteredCount(state);

    const prevStreakEarned = new Set(state.profile.badges.streak || []);
    const prevMasteredEarned = new Set(state.profile.badges.mastered || []);

    const newEarned = []; // for animations/toasts

    // Build fragment
    const frag = document.createDocumentFragment();

    // Streak chip next to profile streak
    const streakEl = document.getElementById('profile-streak');
    if(streakEl && !document.getElementById('streak-chip-el')){
      const chip = document.createElement('span');
      chip.id = 'streak-chip-el';
      chip.className = 'streak-chip';
      chip.innerHTML = 'üî• –°–µ—Ä–∏—è';
      chip.style.marginLeft = '8px';
      streakEl.after(chip);
    }

    // Add all badges (locked or unlocked)
    function createBadge(type, n, unlocked){
      const d = document.createElement('div');
      d.className = 'badge' + (unlocked ? ' unlocked' : ' locked');
      d.innerHTML = `<div class="aura"></div>${badgeSVG(type, n)}<div class="label">${type==='streak'?'—Å–µ—Ä–∏—è':'–ø—Ä–∏–≤—ã—á–∫–∏'}</div><div class="value">${type==='streak'? n+' –¥–Ω–µ–π' : n}</div>`;
      return d;
    }

    // Evaluate unlocks & build UI
    BADGES.streak.forEach(n=>{
      const unlocked = nowStreak >= n;
      const el = createBadge('streak', n, unlocked);
      frag.appendChild(el);
      if(unlocked && !prevStreakEarned.has(n)){
        newEarned.push({type:'streak', n, node:el});
        prevStreakEarned.add(n);
      }
    });

    BADGES.mastered.forEach(n=>{
      const unlocked = masteredCount >= n;
      const el = createBadge('mastered', n, unlocked);
      frag.appendChild(el);
      if(unlocked && !prevMasteredEarned.has(n)){
        newEarned.push({type:'mastered', n, node:el});
        prevMasteredEarned.add(n);
      }
    });

    box.innerHTML='';
    box.appendChild(frag);

    // Persist earned
    state.profile.badges.streak   = Array.from(prevStreakEarned).sort((a,b)=>a-b);
    state.profile.badges.mastered = Array.from(prevMasteredEarned).sort((a,b)=>a-b);
    try{ localStorage.setItem('habit_traker_demo_v3', JSON.stringify(state)); }catch(e){}

    // Animate newly earned
    if(newEarned.length){
      const rect = box.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + 20;
      sparkles(cx, cy);
      const {type, n} = newEarned[newEarned.length-1];
      showToast(type==='streak' ? `–ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ${n} –¥–Ω–µ–π!` : `–ù–æ–≤–∞—è –Ω–∞–≥—Ä–∞–¥–∞: ${n} –ø—Ä–∏–≤—ã—á${n===1?'–∫–∞':'–∫–∏'}`);
      // Emphasize last unlocked badge
      const b = newEarned[newEarned.length-1].node;
      b.style.boxShadow = '0 10px 30px rgba(255,107,61,.45), inset 0 1px 0 rgba(255,255,255,.08)';
      setTimeout(()=> b.style.boxShadow = '', 1200);
    }
  }

  // Hook into existing renderProfile (decorate)
  const origRenderProfile = window.renderProfile;
  window.renderProfile = function(){
    try{
      origRenderProfile && origRenderProfile();
    }catch(e){}
    const s = ensureBadgeState();
    if(s) renderBadges(s);
  };

  // Also re-render badges after any list re-render (progress changes)
  const origRenderAll = window.renderAll;
  window.renderAll = function(){
    origRenderAll && origRenderAll();
    const s = ensureBadgeState();
    if(s) renderBadges(s);
  };

  // First-time ensure & render (in case profile renders before we patch)
  document.addEventListener('DOMContentLoaded', ()=>{
    const s = ensureBadgeState();
    if(s) renderBadges(s);
  });
})();
</script>
<!-- === Gamified Badges Injection: end === -->


<script>
(function(){
  // Robust re-check loop to avoid missing unlocks
  function getState(){
    try{ return JSON.parse(localStorage.getItem('habit_traker_demo_v3')||'null'); }catch(e){ return null; }
  }
  function currentSnapshot(){
    const s = getState();
    if(!s) return {streak:0, mastered:0, badges:{streak:[], mastered:[]}};
    const streak = (s.profile && s.profile.streak) || 0;
    const mastered = (function(){
      let c=0; (s.habits||[]).forEach(h=>{ if(h && h.targetDays && Array.isArray(h.days) && h.days.length >= Math.max(1, h.targetDays)) c++; });
      return c;
    })();
    const b = (s.profile && s.profile.badges) || {streak:[], mastered:[]};
    return {streak, mastered, badges:b};
  }

  let last = currentSnapshot();

  function maybeUpdate(){
    const now = currentSnapshot();
    if(now.streak !== last.streak || now.mastered !== last.mastered ||
       JSON.stringify(now.badges) !== JSON.stringify(last.badges)){
      last = now;
      if(window.renderBadges){
        try{ window.renderBadges(getState()); }catch(e){}
      } else {
        // Fallback: dispatch event to our badge script if it listens
        document.dispatchEvent(new CustomEvent('badges:refresh'));
      }
    }
  }

  // Listen to clicks on day checkboxes to update quickly
  document.addEventListener('click', (e)=>{
    const t = e.target.closest('.today-check,.check');
    if(t){ setTimeout(maybeUpdate, 80); }
  }, {capture:true, passive:true});

  // Also listen to storage changes (other tabs)
  window.addEventListener('storage', (e)=>{
    if(e.key === 'habit_traker_demo_v3'){ maybeUpdate(); }
  });

  // Periodic sanity check
  setInterval(maybeUpdate, 1000);
})();
</script>


<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';

  function getState(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; }
  }

  function localizeStreak(){
    const el = document.getElementById('profile-streak');
    if(!el) return;
    // Extract number from any text and rebuild as "–°–µ—Ä–∏—è: N"
    const m = (el.textContent||'').match(/(\d+)/);
    const n = m ? m[1] : '0';
    el.textContent = '–°–µ—Ä–∏—è: ' + n;

    // Ensure single chip
    const existing = document.querySelectorAll('#streak-chip-el');
    existing.forEach((node, idx) => { if(idx>0) node.remove(); });

    let chip = document.getElementById('streak-chip-el');
    if(!chip){
      chip = document.createElement('span');
      chip.id = 'streak-chip-el';
      chip.className = 'streak-chip';
      chip.textContent = 'üî• –°–µ—Ä–∏—è';
      chip.style.marginLeft = '8px';
      el.after(chip);
    }
  }

  // Safe global refresh used by multiple places
  window.refresh = function(){
    try{
      localizeStreak();
      const s = getState();
      if(s && typeof window.renderBadges === 'function'){
        window.renderBadges(s);
      }
    }catch(e){ /* noop */ }
  };

  // Try to expose renderBadges if it exists inside the previous IIFE via override wrappers already set in v2
  // We also schedule periodic refreshes and on-click updates.
  document.addEventListener('DOMContentLoaded', function(){
    window.refresh();
    document.addEventListener('click', function(e){
      const nav = e.target.closest('.nav-btn');
      if(nav && nav.dataset && nav.dataset.view === 'view-profile'){
        setTimeout(window.refresh, 60);
      }
      if(e.target.closest('.today-check,.check')){
        setTimeout(window.refresh, 80);
      }
    }, {capture:true, passive:true});

    // Fallback periodic refresh
    setInterval(window.refresh, 1200);
  });
})();
</script>


<!-- === Final: Gold Gamified Series Chip === -->
<style>
  /* Hide the original Streak/–°–µ—Ä–∏—è label line beneath avatar */
  #profile-streak{ display:none !important; }

  /* Gold gamified chip */
  .series-chip-gold{
    display:inline-flex; align-items:center; gap:8px;
    padding:8px 12px;
    border-radius:999px;
    font-weight:800; font-size:13px; letter-spacing:.2px;
    color:#1a1400;
    background: radial-gradient(80% 140% at 20% 0%, #ffef9a, #ffd166 50%, #f7b733 80%) ;
    border:1px solid rgba(255,215,120,.8);
    box-shadow:
      0 6px 22px rgba(247,183,51,.45),
      inset 0 1px 0 rgba(255,255,255,.45),
      inset 0 -2px 8px rgba(179,112,0,.25);
    position:relative;
  }
  .series-chip-gold:after{
    content:"";
    position:absolute; inset:-2px;
    border-radius:999px; pointer-events:none;
    background: conic-gradient(from 0deg, rgba(255,255,255,.0), rgba(255,255,255,.22), rgba(255,255,255,.0));
    filter: blur(10px); opacity:.65;
    animation: chip-glow 2.4s linear infinite;
  }
  @keyframes chip-glow{
    0%{ transform: rotate(0deg) }
    100%{ transform: rotate(360deg) }
  }
  .series-chip-gold .flame{
    font-size:16px; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25));
  }
  .series-chip-place{ margin-top:4px; }
</style>
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';

  function getState(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; }
  }

  function ensureSeriesChip(){
    const profile = document.getElementById('view-profile');
    if(!profile) return;

    // Place chip right where medals title is (under avatar/name block)
    // We'll try to insert near the name container
    const nameWrap = profile.querySelector('.name')?.parentElement || profile;
    let holder = document.getElementById('series-chip-holder');
    if(!holder){
      holder = document.createElement('div');
      holder.id = 'series-chip-holder';
      holder.className = 'series-chip-place';
      nameWrap.after(holder);
    }

    let chip = document.getElementById('series-chip-gold');
    if(!chip){
      chip = document.createElement('span');
      chip.id = 'series-chip-gold';
      chip.className = 'series-chip-gold';
      chip.innerHTML = `<span class="flame">üî•</span><span class="txt">–°–µ—Ä–∏—è 0 –¥–Ω–µ–π</span>`;
      holder.innerHTML = '';
      holder.appendChild(chip);
    }
    return chip;
  }

  function updateSeriesChip(){
    const s = getState();
    const chip = ensureSeriesChip();
    if(!chip) return;
    const streak = (s && s.profile && typeof s.profile.streak==='number') ? s.profile.streak : 0;
    const txt = chip.querySelector('.txt');
    if(txt){
      txt.textContent = '–°–µ—Ä–∏—è ' + streak + ' ' + decl(streak, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']);
    }
  }

  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }

  // Public refresh (kept if earlier code uses it)
  window.refresh = function(){
    try{ updateSeriesChip(); if(typeof window.renderBadges==='function'){ const s = getState(); if(s) window.renderBadges(s); } }catch(e){}
  };

  document.addEventListener('DOMContentLoaded', function(){
    updateSeriesChip();
    // re-run when switching to Profile
    document.addEventListener('click', function(ev){
      const nav = ev.target.closest('.nav-btn');
      if(nav && nav.dataset && nav.dataset.view === 'view-profile'){
        setTimeout(updateSeriesChip, 60);
      }
      if(ev.target.closest('.today-check,.check')){
        setTimeout(window.refresh, 100);
      }
    }, {capture:true, passive:true});

    // Light periodic sync
    setInterval(updateSeriesChip, 1500);
  });
})();
</script>
<!-- === /Final: Gold Gamified Series Chip === -->


<!-- === Achievement Modal + Cleanup (v6) === -->
<style>
  /* Modal styles */
  .achv-backdrop{
    position:fixed; inset:0; background:rgba(0,0,0,.55);
    display:none; align-items:center; justify-content:center; z-index:999999;
    backdrop-filter: blur(3px);
  }
  .achv-backdrop.show{ display:flex; }
  .achv-modal{
    width:min(92vw, 380px);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.3));
    border:1px solid rgba(255,255,255,.12);
    border-radius:20px; padding:18px 16px 16px;
    box-shadow:0 18px 50px rgba(0,0,0,.55);
    animation: achv-pop .45s ease both;
  }
  @keyframes achv-pop{ 0%{ transform:scale(.86); opacity:0 } 60%{ transform:scale(1.04); opacity:1 } 100%{ transform:scale(1) } }
  .achv-header{ display:flex; align-items:center; gap:10px; margin-bottom:10px; }
  .achv-icon{
    font-size:22px; line-height:1;
    background: radial-gradient(80% 140% at 20% 0%, #ffef9a, #ffd166 50%, #f7b733 80%);
    padding:8px; border-radius:14px; border:1px solid rgba(255,215,120,.8);
    box-shadow: 0 8px 22px rgba(247,183,51,.35), inset 0 1px 0 rgba(255,255,255,.45);
  }
  .achv-title{ font-weight:900; font-size:16px; }
  .achv-body{ color:var(--muted); font-size:14px; margin-bottom:12px; }
  .achv-actions{ display:flex; gap:8px; justify-content:flex-end; }
  .btn{
    padding:10px 12px; border-radius:12px; cursor:pointer; border:1px solid rgba(255,255,255,.12);
    background:var(--panel); color:#e6eef3;
  }
  .btn.primary{
    background:linear-gradient(90deg, #ffd166, #f7b733);
    color:#1a1400; font-weight:800; border-color:rgba(255,215,120,.8);
    box-shadow: 0 10px 20px rgba(247,183,51,.35);
  }
</style>
<div class="achv-backdrop" id="achv-backdrop" aria-hidden="true">
  <div class="achv-modal" role="dialog" aria-modal="true" aria-labelledby="achv-title">
    <div class="achv-header">
      <div class="achv-icon">üèÜ</div>
      <div class="achv-title" id="achv-title">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ</div>
    </div>
    <div class="achv-body" id="achv-text">–í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É.</div>
    <div class="achv-actions">
      <button class="btn" id="achv-close">–ó–∞–∫—Ä—ã—Ç—å</button>
      <button class="btn primary" id="achv-ok">–ö–ª–∞—Å—Å!</button>
    </div>
  </div>
</div>
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  // Remove legacy chip without number if exists
  function cleanupLegacyChip(){
    const oldChip = document.getElementById('streak-chip-el');
    if(oldChip) oldChip.remove();
  }
  cleanupLegacyChip();

  // Modal helpers
  function openAchv(text){
    try{
      const bd = document.getElementById('achv-backdrop');
      const t  = document.getElementById('achv-text');
      if(!bd || !t) return;
      t.textContent = text || '–í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É.';
      bd.classList.add('show'); bd.setAttribute('aria-hidden','false');
    }catch(e){}
  }
  function closeAchv(){
    try{
      const bd = document.getElementById('achv-backdrop');
      if(!bd) return;
      bd.classList.remove('show'); bd.setAttribute('aria-hidden','true');
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    const bd = document.getElementById('achv-backdrop');
    const ok = document.getElementById('achv-ok');
    const cl = document.getElementById('achv-close');
    ok && ok.addEventListener('click', closeAchv, {passive:true});
    cl && cl.addEventListener('click', closeAchv, {passive:true});
    bd && bd.addEventListener('click', function(e){ if(e.target === bd) closeAchv(); }, {passive:true});
  });

  // Hook into renderBadges to trigger modal on new unlocks
  // We wrap existing window.renderBadges if present, otherwise we create a new one that only sets UI state (no modal triggers).
  (function(){
    const original = window.renderBadges;
    window.renderBadges = function(state){
      const prevStateRaw = localStorage.getItem(STORAGE_KEY);
      let prevBadges = {streak:[], mastered:[]};
      try{
        const s = JSON.parse(prevStateRaw||'null');
        if(s && s.profile && s.profile.badges){
          prevBadges = { 
            streak: Array.isArray(s.profile.badges.streak) ? s.profile.badges.streak.slice() : [],
            mastered: Array.isArray(s.profile.badges.mastered) ? s.profile.badges.mastered.slice() : []
          };
        }
      }catch(_){}

      // Call existing implementation to re-render UI + persist newly earned
      if(typeof original === 'function'){
        original(state);
      }

      // Compare after original render/persist
      try{
        const after = JSON.parse(localStorage.getItem(STORAGE_KEY)||'null');
        let gained = [];
        if(after && after.profile && after.profile.badges){
          const aS = new Set(after.profile.badges.streak||[]);
          const aM = new Set(after.profile.badges.mastered||[]);
          const pS = new Set(prevBadges.streak||[]);
          const pM = new Set(prevBadges.mastered||[]);

          // Any newly added items?
          aS.forEach(n=>{ if(!pS.has(n)) gained.push({type:'streak', n}); });
          aM.forEach(n=>{ if(!pM.has(n)) gained.push({type:'mastered', n}); });
        }
        if(gained.length){
          const last = gained[gained.length-1];
          if(last.type==='streak'){
            openAchv('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ' + last.n + ' ' + decl(last.n, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']));
          } else {
            openAchv('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –û—Å–≤–æ–µ–Ω–æ –ø—Ä–∏–≤—ã—á–µ–∫: ' + last.n);
          }
        }
      }catch(_){}
    };
  })();

  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }
})();
</script>
<!-- === /Achievement Modal + Cleanup (v6) === -->


<!-- === v7: Strong fixes for duplicates & instant achievements === -->
<style>
  /* Ensure profile streak text never shows and can't affect layout */
  #profile-streak{ display:none !important; height:0 !important; overflow:hidden !important; }

  /* Topmost, full-screen modal */
  .achv-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.60);
    display:none; align-items:center; justify-content:center;
    z-index:2147483647; /* absolute top */
    backdrop-filter: blur(3px);
  }
  .achv-backdrop.show{ display:flex; }

  /* When modal open, prevent background scroll */
  body.modal-open{ overflow:hidden; }

  /* Make the modal slightly larger on mobile for "full screen feel" */
  @media (max-width: 480px){
    .achv-modal{ width:92vw; }
  }
</style>
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  const STREAK_STEPS = [7,14,21,30,45,60,75,90,100,120];
  const MASTERED_STEPS = [1,2,3,4,5];

  function getState(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; }
  }
  function setState(s){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){}
  }
  function ensureProfileFields(s){
    s.profile = s.profile || {name:'–ì–æ—Å—Ç—å', avatar:'', streak:0};
    s.profile.badges = s.profile.badges || {streak:[], mastered:[]};
  }
  function computeMastered(s){
    let c=0; (s.habits||[]).forEach(h=>{ if(h && h.targetDays && Array.isArray(h.days) && h.days.length >= Math.max(1,h.targetDays)) c++; });
    return c;
  }
  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }

  /* ===== Duplicate chip prevention ===== */
  function removeLegacyChips(){
    document.querySelectorAll('#streak-chip-el').forEach(n=> n.remove());
  }
  function keepOnlyGoldChip(){
    const holder = document.getElementById('series-chip-holder');
    if(!holder) return;
    const gold = document.getElementById('series-chip-gold');
    // Remove any stray chips inside holder except our gold
    holder.querySelectorAll('span').forEach(n=>{ if(n.id !== 'series-chip-gold') n.remove(); });
    // Also scan profile block for any chips with text "–°–µ—Ä–∏—è" and remove extras
    const prof = document.getElementById('view-profile') || document;
    const chips = prof.querySelectorAll('span');
    let seenGold = false;
    chips.forEach(n=>{
      if(n.id==='series-chip-gold'){ if(seenGold) n.remove(); seenGold=true; }
      else if(/–°–µ—Ä–∏—è/i.test(n.textContent||'')){ n.remove(); }
    });
  }

  /* ===== Modal control ===== */
  function openAchvFullscreen(text){
    const bd = document.getElementById('achv-backdrop');
    const body = document.body;
    const t  = document.getElementById('achv-text');
    if(!bd || !t) return;
    t.textContent = text || '–í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É.';
    bd.classList.add('show');
    body.classList.add('modal-open');
  }
  function closeAchv(){
    const bd = document.getElementById('achv-backdrop');
    const body = document.body;
    if(!bd) return;
    bd.classList.remove('show');
    body.classList.remove('modal-open');
  }
  document.addEventListener('DOMContentLoaded', function(){
    const bd = document.getElementById('achv-backdrop');
    const ok = document.getElementById('achv-ok');
    const cl = document.getElementById('achv-close');
    ok && ok.addEventListener('click', closeAchv, {passive:true});
    cl && cl.addEventListener('click', closeAchv, {passive:true});
    bd && bd.addEventListener('click', function(e){ if(e.target === bd) closeAchv(); }, {passive:true});
  });

  /* ===== Immediate achievement trigger (no refresh needed) ===== */
  function evaluateAndTrigger(){
    const s = getState();
    if(!s) return;
    ensureProfileFields(s);
    const beforeStreak = new Set(s.profile.badges.streak||[]);
    const beforeMastered = new Set(s.profile.badges.mastered||[]);

    const curStreak = s.profile.streak || 0;
    const curMastered = computeMastered(s);

    // Determine which thresholds should be unlocked now
    const newStreak = STREAK_STEPS.filter(n=> curStreak>=n && !beforeStreak.has(n));
    const newMastered = MASTERED_STEPS.filter(n=> curMastered>=n && !beforeMastered.has(n));

    if(newStreak.length || newMastered.length){
      // Persist new earned badges
      const mergedS = new Set([...beforeStreak, ...newStreak]); s.profile.badges.streak = Array.from(mergedS).sort((a,b)=>a-b);
      const mergedM = new Set([...beforeMastered, ...newMastered]); s.profile.badges.mastered = Array.from(mergedM).sort((a,b)=>a-b);
      setState(s);

      // Update medals UI if available
      try{ if(typeof window.renderBadges==='function') window.renderBadges(s); }catch(_){}

      // Open modal for the last newly earned
      const msg = newStreak.length
        ? ('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ' + newStreak[newStreak.length-1] + ' ' + decl(newStreak[newStreak.length-1], ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']))
        : ('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –û—Å–≤–æ–µ–Ω–æ –ø—Ä–∏–≤—ã—á–µ–∫: ' + newMastered[newMastered.length-1]);
      openAchvFullscreen(msg);
    }
  }

  /* Hook clicks on "—Å–µ–≥–æ–¥–Ω—è" and nav to –ø—Ä–æ—Ñ–∏–ª—å */
  document.addEventListener('DOMContentLoaded', function(){
    // Remove any duplicates early
    removeLegacyChips();
    keepOnlyGoldChip();

    document.addEventListener('click', function(e){
      // checkbox click -> short delay to let app update storage, then evaluate
      if(e.target.closest('.today-check,.check')){
        setTimeout(function(){
          try{
            // also update series chip number if our global refresh exists
            if(window.refresh) window.refresh();
            evaluateAndTrigger();
          }catch(_){}
        }, 80);
      }
      // entering profile view -> clean duplicates and update chip text
      const nav = e.target.closest('.nav-btn');
      if(nav && nav.dataset && nav.dataset.view === 'view-profile'){
        setTimeout(function(){
          try{
            removeLegacyChips();
            keepOnlyGoldChip();
            if(window.refresh) window.refresh();
          }catch(_){}
        }, 60);
      }
    }, {capture:true, passive:true});

    // Keep things tidy over time
    setInterval(function(){
      try{
        keepOnlyGoldChip();
      }catch(_){}
    }, 2000);
  });
})();
</script>
<!-- === /v7 fixes === -->


<!-- === v8: Robust streak recompute + full-screen modal behavior === -->
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  const STREAK_STEPS = [7,14,21,30,45,60,75,90,100,120];
  const MASTERED_STEPS = [1,2,3,4,5];

  function getState(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; }
  }
  function setState(s){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){}
  }
  function ensureProfileFields(s){
    s.profile = s.profile || {name:'–ì–æ—Å—Ç—å', avatar:'', streak:0};
    s.profile.badges = s.profile.badges || {streak:[], mastered:[]};
  }
  function isoDate(d){ const t=new Date(d.getFullYear(), d.getMonth(), d.getDate()); return t.toISOString().slice(0,10); }
  function computeStreakFromState(s){
    let streak = 0;
    if(!s || !Array.isArray(s.habits) || s.habits.length===0) return 0;
    const d = new Date();
    while(true){
      const key = isoDate(d);
      const anyDone = s.habits.some(h => Array.isArray(h.days) && h.days.includes(key));
      if(anyDone){ streak++; d.setDate(d.getDate()-1); } else { break; }
    }
    return streak;
  }
  function computeMastered(s){
    let c=0; (s.habits||[]).forEach(h=>{ if(h && h.targetDays && Array.isArray(h.days) && h.days.length >= Math.max(1,h.targetDays)) c++; });
    return c;
  }
  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }

  // Gold series chip updater (single source of truth)
  function updateGoldChip(){
    const holder = document.getElementById('series-chip-holder');
    if(!holder) return;
    let chip = document.getElementById('series-chip-gold');
    if(!chip){
      chip = document.createElement('span');
      chip.id = 'series-chip-gold';
      chip.className = 'series-chip-gold';
      chip.innerHTML = `<span class="flame">üî•</span><span class="txt">–°–µ—Ä–∏—è 0 –¥–Ω–µ–π</span>`;
      holder.innerHTML = ''; holder.appendChild(chip);
    }
    const s = getState(); ensureProfileFields(s);
    const txt = chip.querySelector('.txt');
    const v = typeof s.profile.streak==='number' ? s.profile.streak : 0;
    if(txt) txt.textContent = '–°–µ—Ä–∏—è ' + v + ' ' + decl(v, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']);
  }

  function recomputeAndPersistStreakNow(){
    const s = getState(); if(!s){ return 0; }
    ensureProfileFields(s);
    const v = computeStreakFromState(s);
    if(s.profile.streak !== v){ s.profile.streak = v; setState(s); }
    return v;
  }

  function evaluateAchievementsImmediate(){
    const s = getState(); if(!s) return;
    ensureProfileFields(s);
    const curStreak = s.profile.streak || 0;
    const curMastered = computeMastered(s);
    const prevS = new Set(s.profile.badges.streak||[]);
    const prevM = new Set(s.profile.badges.mastered||[]);
    const newS = STREAK_STEPS.filter(n => curStreak>=n && !prevS.has(n));
    const newM = MASTERED_STEPS.filter(n => curMastered>=n && !prevM.has(n));
    if(newS.length || newM.length){
      s.profile.badges.streak = Array.from(new Set([...prevS, ...newS])).sort((a,b)=>a-b);
      s.profile.badges.mastered = Array.from(new Set([...prevM, ...newM])).sort((a,b)=>a-b);
      setState(s);
      try{ if(typeof window.renderBadges==='function') window.renderBadges(s); }catch(_){}
      const msg = newS.length
        ? ('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ' + newS[newS.length-1] + ' ' + decl(newS[newS.length-1], ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']))
        : ('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –û—Å–≤–æ–µ–Ω–æ –ø—Ä–∏–≤—ã—á–µ–∫: ' + newM[newM.length-1]);
      // open modal (fullscreen; function defined in earlier patch)
      try{
        if(typeof openAchvFullscreen==='function'){ openAchvFullscreen(msg); }
        else {
          // fallback to previous openAchv
          if(typeof openAchv==='function') openAchv(msg);
          // also toggle class to prevent scroll if backdrop exists
          const bd = document.getElementById('achv-backdrop');
          if(bd){ document.body.classList.add('modal-open'); bd.classList.add('show'); }
        }
      }catch(_){}
    }
  }

  // Clean any duplicate chips every so often
  function cleanDuplicates(){
    const holder = document.getElementById('series-chip-holder');
    if(holder){
      // Remove all spans except series-chip-gold
      holder.querySelectorAll('span').forEach(n=>{ if(n.id!=='series-chip-gold') n.remove(); });
    }
    // Remove any old chips elsewhere
    document.querySelectorAll('#streak-chip-el').forEach(n=> n.remove());
  }

  document.addEventListener('DOMContentLoaded', function(){
    // Initial recompute to sync state (ensures streak visible without relying on app render)
    recomputeAndPersistStreakNow();
    updateGoldChip();
    cleanDuplicates();

    // Clicks on "–°–µ–≥–æ–¥–Ω—è" => recompute, update chip, achievements
    document.addEventListener('click', function(e){
      if(e.target.closest('.today-check,.check')){
        setTimeout(function(){
          try{
            recomputeAndPersistStreakNow();
            updateGoldChip();
            evaluateAchievementsImmediate();
          }catch(_){}
        }, 90);
      }
      const nav = e.target.closest('.nav-btn');
      if(nav && nav.dataset && nav.dataset.view==='view-profile'){
        setTimeout(function(){
          try{
            recomputeAndPersistStreakNow();
            updateGoldChip();
            cleanDuplicates();
          }catch(_){}
        }, 60);
      }
    }, {capture:true, passive:true});

    // Periodic safety sync (very light)
    setInterval(function(){
      try{
        recomputeAndPersistStreakNow();
        updateGoldChip();
        cleanDuplicates();
      }catch(_){}
    }, 2000);
  });
})();
</script>
<!-- === /v8 === -->


<!-- === v9: Guaranteed chip + exact mastered trigger on last day === -->
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  const STREAK_STEPS = [7,14,21,30,45,60,75,90,100,120];

  function getState(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; } }
  function setState(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }
  function ensureProfileFields(s){
    s.profile = s.profile || {name:'–ì–æ—Å—Ç—å', avatar:'', streak:0};
    s.profile.badges = s.profile.badges || {streak:[], mastered:[]};
  }
  function isoDate(d){ const t=new Date(d.getFullYear(), d.getMonth(), d.getDate()); return t.toISOString().slice(0,10); }
  function computeStreakFromState(s){
    let streak = 0;
    if(!s || !Array.isArray(s.habits) || s.habits.length===0) return 0;
    const d = new Date();
    while(true){
      const key = isoDate(d);
      const anyDone = s.habits.some(h => Array.isArray(h.days) && h.days.includes(key));
      if(anyDone){ streak++; d.setDate(d.getDate()-1); } else { break; }
    }
    return streak;
  }
  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }

  /* ===== Ensure chip holder & chip exist ===== */
  function ensureGoldChipHolder(){
    const profile = document.getElementById('view-profile');
    if(!profile) return null;
    const nameNode = profile.querySelector('.name');
    let holder = document.getElementById('series-chip-holder');
    if(!holder){
      holder = document.createElement('div');
      holder.id = 'series-chip-holder';
      holder.className = 'series-chip-place';
      if(nameNode && nameNode.parentElement){
        nameNode.parentElement.after(holder);
      } else {
        profile.prepend(holder);
      }
    }
    let chip = document.getElementById('series-chip-gold');
    if(!chip){
      chip = document.createElement('span');
      chip.id = 'series-chip-gold';
      chip.className = 'series-chip-gold';
      chip.innerHTML = `<span class="flame">üî•</span><span class="txt">–°–µ—Ä–∏—è 0 –¥–Ω–µ–π</span>`;
      holder.innerHTML = ''; holder.appendChild(chip);
    }
    return {holder, chip};
  }

  function updateGoldChip(){
    const s = getState(); if(!s) return;
    ensureProfileFields(s);
    const nodes = ensureGoldChipHolder(); if(!nodes) return;
    const txt = nodes.chip.querySelector('.txt');
    const v = typeof s.profile.streak==='number' ? s.profile.streak : 0;
    if(txt) txt.textContent = '–°–µ—Ä–∏—è ' + v + ' ' + decl(v, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']);
  }

  function recomputeAndPersistStreakNow(){
    const s = getState(); if(!s){ return 0; }
    ensureProfileFields(s);
    const v = computeStreakFromState(s);
    if(s.profile.streak !== v){ s.profile.streak = v; setState(s); }
    return v;
  }

  /* ===== Exact "mastered on last day" detection ===== */
  function getMasteredMap(s){
    const map = new Map();
    (s?.habits||[]).forEach(h=>{
      const td = h?.targetDays ? Math.max(1, h.targetDays) : null;
      const done = Array.isArray(h?.days) ? h.days.length : 0;
      map.set(h.id, {target: td, done});
    });
    return map;
  }

  function detectNewMastered(prevMap, nextMap){
    // Returns number of newly mastered habits (transition from done == target-1 to done == target)
    let newCount = 0;
    nextMap.forEach((v, id)=>{
      const p = prevMap.get(id);
      if(!v || !v.target) return;
      const justCompleted = (p && p.done === v.target - 1) && (v.done === v.target);
      if(justCompleted) newCount++;
    });
    return newCount;
  }

  /* ===== Modal helpers (reuse from previous versions if available) ===== */
  function openFullscreen(text){
    if(typeof openAchvFullscreen === 'function'){ openAchvFullscreen(text); return; }
    const bd = document.getElementById('achv-backdrop');
    const t  = document.getElementById('achv-text');
    if(bd && t){
      t.textContent = text || '–í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É.';
      bd.classList.add('show'); document.body.classList.add('modal-open');
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    // Initial sync
    recomputeAndPersistStreakNow();
    updateGoldChip();

    // Click handler with pre/post snapshots to catch "last day" exactly
    document.addEventListener('click', function(e){
      const isToday = !!e.target.closest('.today-check,.check');
      const nav = e.target.closest('.nav-btn');
      let prevMasteredMap = null;
      if(isToday){
        const sPrev = getState() || {};
        prevMasteredMap = getMasteredMap(sPrev);
      }
      // After click is processed by app, recompute
      setTimeout(function(){
        try{
          recomputeAndPersistStreakNow();
          updateGoldChip();

          if(isToday){
            const sNext = getState() || {};
            const nextMasteredMap = getMasteredMap(sNext);

            const newlyMastered = prevMasteredMap ? detectNewMastered(prevMasteredMap, nextMasteredMap) : 0;

            // If exactly completed a habit today -> show mastered modal (single increment)
            if(newlyMastered > 0){
              openFullscreen('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ü—Ä–∏–≤—ã—á–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ üéâ');
              // Also persist mastered badges count threshold if crossed (1..5) now
              const prevBadges = new Set((sPrev?.profile?.badges?.mastered)||[]);
              const masteredCount = Array.from(nextMasteredMap.values()).filter(v=> v.target && v.done >= v.target).length;
              let toAdd = 0;
              for(let step of [1,2,3,4,5]){ if(masteredCount >= step && !prevBadges.has(step)) toAdd = step; }
              if(toAdd){
                const s = getState(); ensureProfileFields(s);
                const setM = new Set((s.profile.badges.mastered)||[]); setM.add(toAdd);
                s.profile.badges.mastered = Array.from(setM).sort((a,b)=>a-b);
                setState(s);
                try{ if(typeof window.renderBadges==='function') window.renderBadges(s); }catch(_){}
              }
            }

            // Streak thresholds check (after recompute)
            const sNow = getState() || {};
            ensureProfileFields(sNow);
            const curStreak = sNow.profile.streak||0;
            const prevS = new Set((sPrev?.profile?.badges?.streak)||[]);
            let streakAdd = 0;
            for(let n of STREAK_STEPS){ if(curStreak>=n && !prevS.has(n)) streakAdd = n; }
            if(streakAdd){
              const s = getState(); ensureProfileFields(s);
              const setS = new Set((s.profile.badges.streak)||[]); setS.add(streakAdd);
              s.profile.badges.streak = Array.from(setS).sort((a,b)=>a-b);
              setState(s);
              try{ if(typeof window.renderBadges==='function') window.renderBadges(s); }catch(_){}
              openFullscreen('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ' + streakAdd + ' ' + decl(streakAdd, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']));
            }
          }
        }catch(_){}
      }, isToday ? 120 : (nav ? 60 : 0));
    }, {capture:true, passive:true});

    // Periodic gentle sync for chip
    setInterval(function(){ try{ recomputeAndPersistStreakNow(); updateGoldChip(); }catch(_){} }, 2500);
  });
})();
</script>
<!-- === /v9 === -->


<!-- === v10: Exact per-habit last-day detection === -->
<script>
(function(){
  const STORAGE_KEY = 'habit_traker_demo_v3';
  const MASTERED_STEPS = [1,2,3,4,5];
  const STREAK_STEPS = [7,14,21,30,45,60,75,90,100,120];

  function getState(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); }catch(e){ return null; } }
  function setState(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }
  function ensureProfileFields(s){
    s.profile = s.profile || {name:'–ì–æ—Å—Ç—å', avatar:'', streak:0};
    s.profile.badges = s.profile.badges || {streak:[], mastered:[]};
  }
  function isoDate(d){ const t=new Date(d.getFullYear(), d.getMonth(), d.getDate()); return t.toISOString().slice(0,10); }
  function decl(n, forms){
    n = Math.abs(n) % 100; var n1 = n % 10;
    if (n>10 && n<20) return forms[2];
    if (n1>1 && n1<5) return forms[1];
    if (n1==1) return forms[0];
    return forms[2];
  }

  function snapshotHabits(s){
    const map = new Map();
    (s?.habits||[]).forEach(h=>{
      const target = h?.targetDays ? Math.max(1, h.targetDays) : null;
      const set = new Set(Array.isArray(h?.days) ? h.days.slice() : []);
      map.set(h.id, {target, set, count: set.size, name: h.name||''});
    });
    return map;
  }
  function masteredCountFromSnapshot(snap){
    let c=0;
    snap.forEach(v=>{ if(v.target && v.count >= v.target) c++; });
    return c;
  }

  // Modal opener fallback
  function openFullscreen(msg){
    if(typeof openAchvFullscreen==='function'){ openAchvFullscreen(msg); return; }
    const bd = document.getElementById('achv-backdrop');
    const t  = document.getElementById('achv-text');
    if(bd && t){
      t.textContent = msg || '–í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É.';
      bd.classList.add('show'); document.body.classList.add('modal-open');
    }
  }

  // On click "–°–µ–≥–æ–¥–Ω—è" -> use per-habit delta detection
  document.addEventListener('DOMContentLoaded', function(){
    document.addEventListener('click', function(e){
      const todayBtn = e.target.closest('.today-check,.check');
      const nav = e.target.closest('.nav-btn');

      let prevSnap = null;
      let prevBadges = null;
      let prevStreakBadges = null;
      let prevStreakVal = null;

      if(todayBtn){
        const sPrev = getState() || {};
        ensureProfileFields(sPrev);
        prevSnap = snapshotHabits(sPrev);
        prevBadges = new Set((sPrev.profile.badges?.mastered)||[]);
        prevStreakBadges = new Set((sPrev.profile.badges?.streak)||[]);
        prevStreakVal = sPrev.profile.streak||0;
      }

      setTimeout(function(){
        try{
          const sNext = getState() || {};
          ensureProfileFields(sNext);

          const nextSnap = snapshotHabits(sNext);
          const today = isoDate(new Date());

          // ===== Exact last-day completion detection =====
          if(prevSnap){
            const newlyCompleted = [];
            nextSnap.forEach((next, id)=>{
              const prev = prevSnap.get(id);
              if(!prev) return;
              // must be a +1 change and today must be newly present
              const delta = next.count - prev.count;
              const todayWas = prev.set.has(today);
              const todayNow = next.set.has(today);
              const isIncrementToday = delta === 1 && !todayWas && todayNow;
              const hitsTargetNow = !!next.target && next.count === next.target;
              if(isIncrementToday && hitsTargetNow){
                newlyCompleted.push({id, name: next.name, target: next.target});
              }
            });

            if(newlyCompleted.length){
              // Update mastered threshold badges based on total mastered count after change
              const prevCount = masteredCountFromSnapshot(prevSnap);
              const nextCount = masteredCountFromSnapshot(nextSnap);
              if(nextCount > prevCount){
                // add highest crossed threshold
                let add = 0;
                for(const step of MASTERED_STEPS){ if(nextCount >= step && !prevBadges.has(step)) add = step; }
                if(add){
                  const setM = new Set(sNext.profile.badges.mastered||[]); setM.add(add);
                  sNext.profile.badges.mastered = Array.from(setM).sort((a,b)=>a-b);
                  setState(sNext);
                  if(typeof window.renderBadges==='function') window.renderBadges(sNext);
                }
              }
              // Show modal once (use the last completed habit)
              const last = newlyCompleted[newlyCompleted.length-1];
              openFullscreen('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ü—Ä–∏–≤—ã—á–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ üéâ');
            }
          }

          // ===== Streak thresholds (use value already maintained by app or our later patches) =====
          const curStreak = (sNext.profile.streak||0);
          let toAddStreak = 0;
          for(const n of STREAK_STEPS){ if(curStreak >= n && !prevStreakBadges?.has(n)) toAddStreak = n; }
          if(toAddStreak){
            const setS = new Set(sNext.profile.badges.streak||[]); setS.add(toAddStreak);
            sNext.profile.badges.streak = Array.from(setS).sort((a,b)=>a-b);
            setState(sNext);
            if(typeof window.renderBadges==='function') window.renderBadges(sNext);
            openFullscreen('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–æ–≤–∞—è —Å–µ—Ä–∏—è: ' + toAddStreak + ' ' + decl(toAddStreak, ['–¥–µ–Ω—å','–¥–Ω—è','–¥–Ω–µ–π']));
          }

          // Keep chip text fresh if our helper exists
          if(typeof window.refresh==='function') window.refresh();
        }catch(_){}
      }, todayBtn ? 140 : (nav ? 70 : 0));
    }, {capture:true, passive:true});
  });
})();
</script>
<!-- === /v10 === -->

</body>
</html>
